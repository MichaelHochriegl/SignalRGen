@page "/Chat"
@using SignalRGen.Example.Contracts

@* We inject the generated client. *@
@* Notice that we use the actual type, not the interface we defined. *@
@inject ChatHubContractClient ChatHubClient;

<h3>Chat</h3>

<p>This is a really crude example of a chat that uses SignalR generated by SignalRGen to communicate.</p>
<p>It is kept simple to better showcase the generated SignalR code. This is not how a real chat app would look like.</p>
<p>To get the example working it is best to duplicate this tab a couple of times and open them in different browser tabs.
    After that enter a username in each tab and join the chat room. You should be able to see the sent message on all tabs.</p>
@if (!_joined)
{
    <div class="username-section">
        <input type="text" @bind="_username" placeholder="Enter username"/>
        <button @onclick="Join" disabled="@(!string.IsNullOrEmpty(_confirmedUsername))">Join</button>
    </div>
}
else
{
    <div class="chatting-as-section">
        <p>Chatting as: <span>@_confirmedUsername</span></p>
    </div>
    <div class="message-section">
        <input type="text" @bind="_message" placeholder="Enter message"/>
        <button @onclick="SendMessage">Send</button>
        <div class="messages">
            @foreach (var message in _messages)
            {
                <div>@message</div>
            }
        </div>
    </div>
}

@code {
    private string _username = string.Empty;
    private string _confirmedUsername = string.Empty;
    private bool _joined = false;
    private string _message = string.Empty;
    private List<string> _messages = new();

    private async Task Join()
    {
        if (!string.IsNullOrWhiteSpace(_username))
        {
            _confirmedUsername = _username;
            _username = string.Empty;
            _joined = true;

            // We subscribe to the `OnUserJoined` event to get notified whenever a new user joined.
            ChatHubClient.OnUserJoined += async user =>
            {
                _messages.Add($"~~ User '{user}' joined ~~");
                await InvokeAsync(StateHasChanged);
            };
            
            // We subscribe to the `OnUserLeft` event to get notified whenever a user left.
            ChatHubClient.OnUserLeft += async user =>
            {
                _messages.Add($"~~ User '{user}' left ~~");
                await InvokeAsync(StateHasChanged);
            };
            
            // We subscribe to the `OnMessageReceived` event to get notified whenever a new message
            // was sent by other users.
            ChatHubClient.OnMessageReceived += async (user, message) =>
            {
                _messages.Add($"{user}: {message}");
                await InvokeAsync(StateHasChanged);
            };
            
            // We use the headers in this stripped-down example as a means to send the username along.
            // In a real chat app this would be dealt with differently, but it is a nice showcase
            // on how to pass along runtime-based headers.
            var headers = new Dictionary<string, string>()
            {
                { "username", _confirmedUsername }
            };
            
            // We start the Hub, which will internally build up the connection to the server.
            await ChatHubClient.StartAsync(headers: headers);
        }
    }

    private async Task SendMessage()
    {
        // We are invoking the `InvokeSendMessageAsync` method to send the message to the server,
        // which will propagate it to the other users.
        await ChatHubClient.InvokeSendMessageAsync(_message);
        _messages.Add($"{_confirmedUsername}: {_message}");
        await InvokeAsync(StateHasChanged);
        _message = string.Empty;
    }

}