# Getting Started

Follow the steps below to create your first SignalR Hub that will have two basic methods:
1. Send data from the server to a client
2. Send data from a client to the server

::: tip
This getting started also creates the projects for the above-mentioned projects.
If you want to go straight to the [installation](#install-signalrgen) or directly to the 
[usage](#define-the-signalr-interface) of `SignalRGen` you can do so by clicking the links.
:::

## Create Projects & Install Package

### Solution
Create a solution to hold our projects:

::: code-group
```shell
mkdir MySignalRGenExample
cd MySignalRGenExample
dotnet new sln -n MySignalRGenExample
```
:::

### Server Project
Let's create the server project and add it to the solution
(note that we are still in the `MySignalRGenExample` directory from the above `cd`):

::: code-group
```shell
dotnet new web -n MyServer
dotnet sln add MyServer/MyServer.csproj
```
:::

### Client Project
Next create the client project and add it to the solution
(note that we are still in the `MySignalRGenExample` directory from the above `cd`):

::: code-group
```shell
dotnet new web -n MyClient
dotnet sln add MyClient/MyClient.csproj
```
:::

### SignalR Interface Project
And finally, the shared project where our SignalR Interface description will live
(note that we are still in the `MySignalRGenExample` directory from the above `cd`):

::: code-group
```shell
dotnet new classlib -n MySharedInterface
dotnet sln add MySharedInterface/MySharedInterface.csproj
```
:::

### Install `SignalRGen` and dependencies
The [SignalR Interface Project](#signalr-interface-project) will hold our interface descriptions. That's where we need to install `SignalRGen` to:

::: code-group

```shell [Navigate to project]
cd MySharedInterface
```

:::

::: code-group
```shell [Install SignalRGen]
dotnet add package SignalRGen
```

```shell [Install Microsoft.AspNetCore.SignalR.Client]
dotnet add package Microsoft.AspNetCore.SignalR.Client
```
:::

As `SignalRGen` is a source generator we need to update the project reference that the above install command added to our `csproj`:
```xml
<PackageReference Include="SignalRGen" Version="1.0.0">
    <!-- Add these two lines -->
    <PrivateAssets>all</PrivateAssets>
    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
</PackageReference>
```

If you are not following the example project setup and just want to directly install `SignalRGen` 
into your (preferably shared class lib) project you can do so with:

::: code-group
```shell
cd {This-is-your-project-path}
dotnet add package SignalRGen
```
:::


## Define the SignalR Interface

If you are following the example, we will create the below `Interface` in the `MySharedInterface` project,
however, if you roll your own project, you will add that where you [installed](#install-signalrgen) `SignalRGen` to.

```csharp
using SignalRGen.Generator;

namespace MySharedInterface;

[HubClient(HubUri = "ping-pong")]
public interface IPingPongHub
{
    [ClientToServerMethod]
    Task Ping(string message);

    Task Pong(string answer);
}
```

With this defined, the appropriate hub was autogenerated by `SignalRGen`.

## Add project references

To have access to the generated code, both projects, `MyClient` and `MyServer` need a reference
to the `MySharedInterface` project.

::: code-group
```shell [Add reference to MyServer project]
dotnet reference add MySharedInterface/MySharedInterface.csproj --project MyServer/MyServer.csproj
```

```shell [Add reference to MyClient project]
dotnet reference add MySharedInterface/MySharedInterface.csproj --project MyClient/MyClient.csproj
```
:::

## Create `Hub` on server side

As the serverside code is really use-case-dependent `SignalRGen` is not generating the actual `Hub` for you.
A basic `Hub` implementation could look like this:

::: code-group

```csharp
using Microsoft.AspNetCore.SignalR;
using MySharedInterface;

namespace MyServer;

public class PongHub : Hub<IPingPongHub>, IPingPongHub
{
    private readonly ILogger<PongHub> _logger;

    public PongHub(ILogger<PongHub> logger)
    {
        _logger = logger;
    }
    
    public Task Ping(string message)
    {
        _logger.LogInformation("Received Ping: {Message}", message);
        return Clients.All.Pong("Hey, here is the server talking!");
    }

    public Task Pong(string answer)
    {
        throw new InvalidOperationException("This is a Server-to-Client method, hence it is not implemented!");
    }
}
```

:::

## Create background worker on client side

To constantly have a connection to the server we are going to use a background worker.
This worker will connect to the server when the project starts and disconnects when it shuts down.

For this we add the following `IHostedService` in the client project:
::: code-group

```csharp
using MySharedInterface;

namespace MyClient;

public class Worker : IHostedService
{
    private readonly ILogger<Worker> _logger;
    private readonly PingPongHub _hub;

    public Worker(ILogger<Worker> logger, PingPongHub hub)
    {
        _logger = logger;
        _hub = hub;
    }
    
    public Task StartAsync(CancellationToken cancellationToken)
    {
        _hub.OnPong += OnPongReceived;

        return _hub.StartAsync(cancellationToken: cancellationToken);
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        return _hub.StopAsync(cancellationToken: cancellationToken);
    }

    private Task OnPongReceived(string answer)
    {
        _logger.LogInformation("Received Pong: {Answer}", answer);

        return Task.CompletedTask;
    }
}
```

:::

We add this `Worker` with this line in the DI container:

::: code-group

```csharp [Program.cs]
builder.Services.AddHostedService<Worker>();
```

:::

## Setup `Hub` on client DI container

Now for the actual part where `SignalRGen` shines: Easy client-side integration of the `Hubs`.
Given our `IPingPongHub` created in [Define the SignalR Interface](#define-the-signalr-interface) we wire everything up with:

::: code-group

```csharp [Program.cs]
builder.Services.AddSignalRHubs(c => c.HubBaseUri = new Uri("http://localhost:5160"))
    .WithPingPongHub();
```

:::

::: tip
This is just a very basic configuration, `SignalRGen` allows for way more customization regarding the `Hub`.
All the possible configuration-settings can be found [here](../configuration/config-overview.md).
:::

## Trigger Client-to-Server method

To try out the Client-to-Server method, we create a minimal API endpoint in our `MyClient` project:

::: code-group

```csharp [Program.cs]
app.MapGet("/ping", async ([FromServices] PingPongHub hub) =>
{
    await hub.InvokePingAsync("Hello from the client!");
});
```

:::

::: warning Important!
Note that we injected the `PingPongHub` and not the `IPingPongHub`. The latter is "only" the interface we defined
and **not** the actual `HubClient`.

The `PingPongHub` without the `I` is the generated `HubClient` which allows you to subscribe to
ServerToClient` methods and trigger `ClientToServer` methods.
:::