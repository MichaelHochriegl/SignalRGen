//HintName: FakeEmptyHubClient.g.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable
namespace SignalRGen.Clients.TestFakes;


public sealed class FakeEmptyHubClient : SignalRGen.Clients.EmptyHubClient
{
    private readonly global::System.Threading.Lock _lock = new();


    /// <summary>
    /// When true, the fake client operates in strict mode:
    /// any unconfigured or unexpected invocation will throw an exception.
    /// Use to ensure tests explicitly define expected interactions.
    /// </summary>
    public bool Strict { get; set; }

    public FakeEmptyHubClient(
             global::System.Action<global::Microsoft.AspNetCore.SignalR.Client.IHubConnectionBuilder>? hubConnectionBuilderConfiguration = null,
             global::System.Uri? baseHubUri = null,
             global::System.Action<global::Microsoft.AspNetCore.Http.Connections.Client.HttpConnectionOptions>? httpConnectionOptionsConfiguration = null)
             : base(hubConnectionBuilderConfiguration, baseHubUri ?? new global::System.Uri("http://localhost/"), httpConnectionOptionsConfiguration)
    {
    }

    protected override void RegisterHubMethods()
    {
    }

    public override global::System.Threading.Tasks.Task StartAsync(
        global::System.Collections.Generic.Dictionary<string, string>? queryStrings = null,
        global::System.Collections.Generic.Dictionary<string, string>? headers = null,
        global::System.Threading.CancellationToken cancellationToken = default)
    {
        var builder = new global::Microsoft.AspNetCore.SignalR.Client.HubConnectionBuilder();
        
        global::Microsoft.AspNetCore.SignalR.Client.HubConnectionBuilderHttpExtensions
                                               .WithUrl(builder, "http://localhost");
        
        _hubConnection = builder.Build();
        
        return global::System.Threading.Tasks.Task.CompletedTask;
    }

    public override global::System.Threading.Tasks.Task StopAsync(global::System.Threading.CancellationToken cancellationToken = default) => global::System.Threading.Tasks.Task.CompletedTask;

    protected override async global::System.Threading.Tasks.Task InvokeCoreAsync(string methodName, object?[] args, global::System.Threading.CancellationToken cancellationToken)
    {
        switch (methodName)
        {
       
           default:
                if (Strict) throw new global::System.NotSupportedException($"Method '{methodName}' is not supported by the fake.");
                return;
        }
    }

    protected override async global::System.Threading.Tasks.Task<TResult> InvokeCoreAsync<TResult>(string methodName, object?[] args, global::System.Threading.CancellationToken cancellationToken)
    {
        switch (methodName)
        {
       
           default:
                if (Strict) throw new global::System.NotSupportedException($"Method '{methodName}' is not supported by the fake.");
                return default!;
        }
    }

    public void ClearRecorded()
    {
        lock (_lock)
        {

        }
    }
}